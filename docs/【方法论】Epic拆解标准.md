# Epic拆解方法论

基于对【技术架构】系统设计方案.md和【PRD】小说创作工具.md的深度理解，制定以下Epic详细拆解方法论。

## 一、核心设计理念

### 1.1 架构约束原则
- **前后端分离**：严格遵循Client/Server架构，职责边界清晰
- **低耦合高内聚**：模块间通过标准化API通信，内部逻辑高度聚合
- **健壮性优先**：每个模块都有完整错误处理和降级机制
- **本地化优先**：用户数据完全本地控制，无云端依赖
- **AI驱动核心**：4角色协作是系统核心业务逻辑

### 1.2 技术栈约束
- **前端**：React 18 + TypeScript + Zustand + Shadcn/ui + Monaco Editor
- **后端**：Node.js + Express + TypeScript + Gemini API + MCP SDK
- **基础**：Redis + Docker + 严格的统一目录结构

## 二、Epic拆解标准化模板

### 2.1 Story拆解结构
每个Epic按以下开发顺序拆解：

```
Epic N: [Epic名称]
├── Story N.1: 界面功能开发
├── Story N.2: 服务逻辑开发  
├── Story N.3: 功能集成开发
└── Story N.4: 完整功能验证
```

### 2.2 Story详细拆解模板

#### **Story 1: 界面功能开发模板**
```markdown
# Story N.1: [功能]界面功能开发

## 开发目标
[具体要实现的界面功能和用户交互]

## ⚠️ 防改错约束（执行前必须检查）
### 修改前强制步骤
- [ ] **完整阅读相关代码**：使用Read工具阅读所有相关文件
- [ ] **理解现状确认**：用自己的话描述当前代码的工作原理
- [ ] **明确修改边界**：具体列出要修改的文件和函数
- [ ] **识别保护区域**：明确哪些代码绝对不能修改

### 核心保护区域（绝对禁止修改）
- [ ] 已定义的API接口签名
- [ ] 核心数据结构定义
- [ ] 状态管理模型
- [ ] 错误处理基础框架

### 安全修改原则
- [ ] **向后兼容**：新功能不破坏现有功能
- [ ] **原子修改**：每次只修改一个具体功能点
- [ ] **即时验证**：修改后立即验证功能正常

## 技术实现要求
### 界面开发规范
- **组件库**：Shadcn/ui，严格使用黑白灰配色方案
- **类型安全**：TypeScript强制类型检查，完整类型定义
- **状态管理**：Zustand管理状态，明确状态边界
- **响应式设计**：支持不同屏幕尺寸适配

### 界面开发清单
- [ ] [具体界面1]：[功能描述]
- [ ] [具体界面2]：[功能描述]
- [ ] [具体界面3]：[功能描述]

### 开发规范
- **前端目录**：严格按照 src/client/components/[模块]/[组件名]/ 组织
- **文件命名**：组件文件.tsx + 样式文件.module.css + 类型文件.types.ts
- **代码质量**：ESLint检查通过，无TypeScript错误

## 验收标准
- [ ] 界面功能完全符合PRD设计规范
- [ ] 所有用户交互正常工作
- [ ] 响应式布局在不同屏幕下正常显示
- [ ] TypeScript编译无错误
- [ ] 界面组件可复用性良好

## ✅ 完成后强制验证
- [ ] **界面功能验证**：新界面按预期工作
- [ ] **交互功能验证**：用户操作流程正常
- [ ] **兼容性验证**：没有破坏现有界面和交互

## 开发步骤依赖
**前置条件**：[需要先完成的准备工作]
**后续步骤**：为Story 2服务逻辑开发提供界面基础
```

#### **Story 2: 服务逻辑开发模板**
```markdown
# Story N.2: [功能]服务逻辑开发

## 开发目标
[具体要实现的业务逻辑和服务能力]

## ⚠️ 防改错约束（执行前必须检查）
### 修改前强制步骤
- [ ] **完整阅读相关代码**：使用Read工具阅读所有相关文件
- [ ] **理解现状确认**：用自己的话描述当前代码的工作原理
- [ ] **明确修改边界**：具体列出要修改的文件和函数
- [ ] **识别保护区域**：明确哪些代码绝对不能修改

### 核心保护区域（绝对禁止修改）
- [ ] API响应格式结构：`{success, data, error, timestamp}`
- [ ] 已有路由接口签名
- [ ] 错误处理基础类
- [ ] 数据验证中间件

### 安全修改原则
- [ ] **向后兼容**：API接口只能扩展，不能破坏
- [ ] **原子修改**：每次只修改一个具体服务功能
- [ ] **即时验证**：修改后立即测试API功能

## 技术实现要求
### 服务开发规范
- **框架**：Express + TypeScript，严格MVC架构
- **错误处理**：分层错误类，统一错误响应格式
- **安全机制**：helmet + cors + 数据验证
- **性能优化**：Redis缓存 + 异步处理

### 服务开发清单
- [ ] **路由层**：/api/[模块]/[接口] 路由定义
- [ ] **服务层**：核心业务逻辑实现
- [ ] **数据层**：Redis缓存管理和文件操作
- [ ] **中间件**：认证/校验/日志中间件

### 重点开发模块
根据Epic特点，重点实现：
- **AI服务模块**：Gemini API + PromptX MCP集成
- **文件操作模块**：本地文件读写和File System Access API
- **项目管理模块**：依赖识别和状态管理
- **记忆管理模块**：Redis短期 + PromptX长期记忆

## 验收标准
- [ ] 服务功能完全符合业务需求
- [ ] 错误处理和重试机制完整
- [ ] 性能满足响应时间要求（<1s）
- [ ] 核心业务逻辑测试通过
- [ ] API接口全流程验证通过

## ✅ 完成后强制验证
- [ ] **服务功能验证**：新服务按预期工作
- [ ] **向后兼容验证**：原有服务仍然正常
- [ ] **错误处理验证**：异常场景处理正确
- [ ] **性能验证**：响应时间符合要求

## 开发步骤依赖
**前置条件**：Story 1界面功能已完成
**技术依赖**：Gemini API密钥、Redis服务、PromptX MCP服务
**后续步骤**：为Story 3功能集成提供服务基础
```

#### **Story 3: 功能集成开发模板**
```markdown
# Story N.3: [功能]功能集成开发

## 开发目标
完成界面与服务的集成，实现完整的功能流程

## ⚠️ 防改错约束（执行前必须检查）
### 修改前强制步骤
- [ ] **完整阅读相关代码**：使用Read工具阅读界面和服务相关文件
- [ ] **理解现状确认**：描述当前数据流和功能工作原理
- [ ] **明确集成边界**：确定要修改的接口和数据流
- [ ] **识别保护区域**：明确哪些协议绝对不能修改

### 核心保护区域（绝对禁止修改）
- [ ] 统一API响应格式：`{success, data, error, timestamp}`
- [ ] 已有接口的请求/响应结构
- [ ] WebSocket事件协议定义
- [ ] 错误码标准定义

### 安全集成原则
- [ ] **协议向后兼容**：新功能不破坏现有通信
- [ ] **数据结构兼容**：只能扩展字段，不能修改现有字段
- [ ] **分步集成验证**：每个功能集成后立即验证

## 技术实现要求
### 集成开发规范
确保界面与服务的无缝连接：
```typescript
interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: number;
}
```

### 集成开发要点
- **接口调用**：前端正确调用后端API接口
- **数据传输**：请求参数和响应数据格式正确
- **错误处理**：前端正确处理后端返回的错误信息
- **状态管理**：前端状态与后端数据保持同步

### 集成开发清单
- [ ] 界面与API的连接调试
- [ ] 数据流验证和错误处理
- [ ] 用户交互完整流程测试
- [ ] WebSocket实时通信集成（如需要）

## 验收标准
- [ ] 功能集成完整准确
- [ ] 界面与服务数据流通畅
- [ ] 错误处理机制完善
- [ ] 功能性能满足要求

## ✅ 完成后强制验证
- [ ] **功能完整性验证**：集成功能完全工作
- [ ] **数据流验证**：界面与服务数据正确传输
- [ ] **错误处理验证**：异常情况正确处理
- [ ] **性能验证**：功能响应时间符合要求

## 开发步骤依赖
**前置条件**：Story 1界面功能和Story 2服务逻辑都已完成
**后续步骤**：为Story 4完整功能验证提供集成基础
```

#### **Story 4: 完整功能验证模板**
```markdown
# Story N.4: [功能]完整功能验证

## 验证目标
验证完整功能从用户界面到业务服务的端到端流程

## ⚠️ 防改错约束（验证前必须检查）
### 验证前强制步骤
- [ ] **完整理解系统**：阅读所有相关组件和服务代码
- [ ] **确认验证范围**：明确要验证哪些功能和流程
- [ ] **识别风险点**：确定可能出现问题的关键环节
- [ ] **准备回滚方案**：如发现问题如何快速恢复

### 验证约束原则
- [ ] **只验证不修改**：验证过程中发现问题只记录，不直接修改代码
- [ ] **完整流程验证**：从用户操作到最终结果的完整链路
- [ ] **异常场景覆盖**：确保异常情况得到正确处理

## 验证场景清单
- [ ] **正常流程**：[用户操作] → [界面反应] → [后端处理] → [结果返回]
- [ ] **异常场景**：[错误输入] → [错误处理] → [用户提示]
- [ ] **边界情况**：[极端数据] → [系统处理] → [稳定性验证]

## 功能验证标准
- [ ] 用户界面操作流畅自然
- [ ] 数据处理准确无误
- [ ] 错误处理用户友好
- [ ] 性能满足PRD要求
- [ ] 符合业务流程规范

## 回归测试
- [ ] 相关功能模块回归测试
- [ ] 系统稳定性验证
- [ ] 用户体验评估

## 开发步骤依赖
**前置条件**：前3个Story全部完成
**输出结果**：Epic功能完全就绪，可进入下个Epic
```

## 三、开发顺序规范

### 3.1 功能开发原则
- **界面优先**：先完成用户界面，明确交互需求
- **服务支撑**：基于界面需求开发后端服务逻辑
- **集成验证**：确保界面与服务完美配合

### 3.2 Epic内部顺序
```
Story 1 (界面功能) → Story 2 (服务逻辑) → Story 3 (功能集成) → Story 4 (完整验证)
        ↓                    ↓                    ↓
    明确交互需求          提供服务支撑          实现完整功能
```

### 3.3 Epic间开发顺序
- Epic 1-3：基础架构层，必须串行完成
- Epic 4-5：AI服务层，严格按顺序
- Epic 6-11：业务功能层，按创作流程顺序
- Epic 12：优化完善层，最后实施

## 四、质量保证机制

### 4.1 开发标准
- **代码规范**：TypeScript严格模式，ESLint检查
- **测试覆盖**：核心业务逻辑单元测试，API集成测试
- **性能要求**：接口响应<1s，界面交互<100ms
- **兼容性**：支持主流浏览器最新2个版本

### 4.2 验收标准
- **功能完整性**：严格按PRD功能要求验收
- **用户体验**：符合界面设计和交互规范
- **稳定可靠**：错误处理完善，系统健壮
- **性能达标**：满足响应时间和资源占用要求

## 五、特殊处理规则

### 5.1 AI服务集成特殊性
- **Gemini API优先**：当前版本只支持Gemini，但架构预留扩展性
- **PromptX MCP集成**：严格按MCP协议标准实现
- **4角色系统**：总监→完整4角色的渐进式集成策略

### 5.2 文件操作特殊性
- **本地化优先**：优先File System Access API，降级到上传下载
- **实时同步**：30秒自动保存+手动保存双重机制
- **目录规范**：严格的4目录结构识别和创建

### 5.3 界面交互特殊性
- **双栏架构**：320px左侧+自适应右侧的固定布局
- **双层Tab**：顶层文件Tab+内层依赖链Tab的复杂交互
- **极简设计**：黑白灰配色，Shadcn/ui组件库

## 六、AI连续工作机制（奥卡姆剃刀原则）

### 6.1 核心问题：AI记忆断裂
**问题**：AI无法保持开发上下文连续性，导致重复开发、冲突修改、架构偏离
**解决方案**：文档驱动的外化记忆机制

### 6.2 Epic内状态管理（最简方案）
#### 每个Epic文件增强结构
```markdown
# Epic N: [Epic名称]

## 📋 开发状态（AI必读必写）
### 当前进度
- [ ] Story N.1: 前端UI组件开发 - 状态：[未开始/进行中XX%/已完成]
- [ ] Story N.2: 后端业务服务开发 - 状态：[未开始/进行中XX%/已完成]  
- [ ] Story N.3: 接口协议制定和集成 - 状态：[未开始/进行中XX%/已完成]
- [ ] Story N.4: 端到端功能验证 - 状态：[未开始/进行中XX%/已完成]

### 正在进行的工作
- **当前Story**：[具体Story编号和名称]
- **具体任务**：[当前正在做什么]
- **修改文件**：[涉及哪些文件]
- **预期完成**：[预计何时完成]

### 关键决策和约束
- **技术决策**：[本Epic确定的重要技术方案]
- **API设计**：[新增或修改的接口]
- **数据结构**：[重要的数据模型变更]
- **限制条件**：[遇到的技术限制或问题]

### 依赖关系和约束
#### 来自前置Epic的关键约束
- [具体约束1]：[详细说明]
- [具体约束2]：[详细说明]

#### 本Epic产出的关键决策（影响后续Epic）
- [待完成后填写]：[本Epic确定的设计决策和约束]

## Epic详细拆解
[原有的Story拆解内容]
```

### 6.3 开发总结备份机制
#### 时间戳总结文件夹
```
docs/开发总结/
├── 2025-01-15_14-30_Epic1-Story1完成.md
├── 2025-01-15_16-45_Epic1-Story2进度50%.md
├── 2025-01-16_10-15_Epic1完成总结.md
└── 2025-01-16_11-00_开始Epic2.md
```

#### 总结文件标准格式
```markdown
# 开发总结 - [时间戳]

## 修改内容
- [文件路径] - [具体修改内容]
- [文件路径] - [具体修改内容]

## 修改原因
[为什么修改，解决什么问题]

## 当前状态
- Story进度：[完成到哪个Story]
- 下个任务：[具体要做什么]
```

### 6.4 AI执行规范（强制遵守）

#### 6.4.1 执行前检查清单（每个Story都必须执行）
```markdown
## 🚨 开始任何Story前必须完成以下检查：

### Step 0: 状态恢复（记忆连续性保证）
- [ ] **强制读取当前Epic文件**：完整阅读当前Epic的"开发状态"部分
- [ ] **理解项目当前状态**：明确当前在哪个Story，做到什么程度
- [ ] **确认任务边界**：明确这次要做什么，不做什么
- [ ] **识别约束条件**：检查前置Epic的约束和本Epic的限制

### Step 1: 理解阶段
- [ ] 使用Read工具完整阅读所有相关代码文件
- [ ] 用自己的话描述当前代码的工作原理
- [ ] 明确说明要实现的功能目标

### Step 2: 边界确认
- [ ] 具体列出要修改的文件和函数
- [ ] 明确标识绝对不能修改的保护区域
- [ ] 确认修改方式符合向后兼容原则

### Step 3: 安全准备
- [ ] 制定原子化的修改步骤（每步只改一个功能点）
- [ ] 确认每步修改后的验证方式
- [ ] 准备问题出现时的快速回滚方案
```

### 6.2 执行中约束（修改过程中强制遵守）
```markdown
## 🔒 修改过程中的强制约束：

### 原子修改原则
- 每次只修改一个具体功能点
- 修改后立即验证功能正常
- 发现问题立即停止，分析原因

### 兼容性原则
- API接口只能扩展，不能破坏现有签名
- 数据结构只能增加字段，不能删除或重命名
- 保持所有现有功能的行为不变

### 验证原则
- 新功能必须按预期工作
- 原有功能必须仍然正常
- 所有相关功能模块必须回归测试通过
```

### 6.3 问题处理机制
```markdown
## 🛑 遇到以下情况必须立即停止：

1. **理解不清楚**：无法准确描述现有代码工作原理
2. **影响不确定**：不确定修改会影响哪些其他功能
3. **验证失败**：修改后功能验证不通过
4. **兼容性问题**：修改可能破坏现有接口或数据结构

## 📋 问题处理流程：
1. 立即停止当前修改
2. 详细记录发现的问题
3. 分析问题根本原因
4. 重新制定修改方案
5. 从Step 1重新开始执行
```

#### 6.4.4 状态保存（完成任何工作后强制执行）
```markdown
## 📝 完成任何开发工作后必须同时更新：

### 1. 强制更新当前Epic文件的"开发状态"部分
- [ ] **更新Story进度**：修改对应Story的状态（进行中XX%/已完成）
- [ ] **记录正在进行的工作**：更新当前任务、修改文件、预期完成时间
- [ ] **记录关键决策**：新的技术决策、API设计、数据结构变更
- [ ] **更新约束信息**：本Epic对后续Epic的影响

### 2. 创建时间戳开发总结文件
- [ ] **文件命名**：docs/开发总结/[YYYY-MM-DD_HH-mm]_[具体内容].md
- [ ] **记录修改内容**：修改的文件和具体内容
- [ ] **说明修改原因**：为什么修改，解决什么问题
- [ ] **更新当前状态**：Story进度，下个任务
```

### 6.5 核心原则总结
- **奥卡姆剃刀**：用最简单的方式解决记忆连续性问题
- **文档驱动**：AI的"大脑"外化到文件系统，信息持久化
- **强制执行**：状态管理嵌入工作流程，不可绕过
- **串行开发**：同时只关注一个Epic，避免复杂的并发状态管理

---

**核心目标**：通过文档驱动的状态管理确保AI记忆连续性，同时通过系统性约束避免破坏性修改。每个检查都是必须项，不是可选项。