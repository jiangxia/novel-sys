# Epic拆解方法论

基于对【技术架构】系统设计方案.md和【PRD】小说创作工具.md的深度理解，制定以下Epic详细拆解方法论。

🚨 **AI强制执行警示** 🚨  
**本方法论是强制标准，不可偏离！任何Epic拆解必须严格遵循4-Story结构和标准模板！**

---

## 一、方法论核心(15%)

### 1.1 核心设计理念

#### 架构约束原则
- **前后端分离**：严格遵循Client/Server架构，职责边界清晰
- **低耦合高内聚**：模块间通过标准化API通信，内部逻辑高度聚合
- **健壮性优先**：每个模块都有完整错误处理和降级机制
- **本地化优先**：用户数据完全本地控制，无云端依赖
- **AI驱动核心**：4角色协作是系统核心业务逻辑

#### 技术栈约束
- **前端**：React 18 + TypeScript + Vite + Zustand + Shadcn/ui + Monaco Editor
- **后端**：Node.js + Express + TypeScript + Gemini API + MCP SDK
- **架构**：前后端分离 + 本地文件系统 + File System Access API

### 1.2 标准化4-Story结构

🚨 **强制4-Story结构** 🚨  
**每个Epic必须且只能按以下开发顺序拆解，不得增加、删除或修改：**

```
Epic N: [Epic名称]
├── Story N.1: 界面功能开发  ← 🔒 强制格式，不可更改
├── Story N.2: 服务逻辑开发  ← 🔒 强制格式，不可更改
├── Story N.3: 功能集成开发  ← 🔒 强制格式，不可更改
└── Story N.4: 完整功能验证  ← 🔒 强制格式，不可更改
```

⚠️ **Epic0成功案例参考**：`【Epic0】技术环境搭建.md` 严格按此结构执行并成功完成

### 1.3 开发顺序规范

#### 功能开发原则
- **界面优先**：先完成用户界面，明确交互需求
- **服务支撑**：基于界面需求开发后端服务逻辑
- **集成验证**：确保界面与服务完美配合

#### Epic内部顺序
```
Story 1 (界面功能) → Story 2 (服务逻辑) → Story 3 (功能集成) → Story 4 (完整验证)
        ↓                    ↓                    ↓
    明确交互需求          提供服务支撑          实现完整功能
```

#### Epic间开发顺序
- Epic 1-3：基础架构层，必须串行完成
- Epic 4-5：AI服务层，严格按顺序
- Epic 6-11：业务功能层，按创作流程顺序
- Epic 12：优化完善层，最后实施

---

## 二、执行标准(60%)

### 2.1 执行前强制检查清单

#### 每次拆解Epic前必须确认：
- [ ] **只能生成1个Epic文件**：`【Epic[编号]】[Epic名称].md`
- [ ] **必须使用4-Story结构**：界面功能→服务逻辑→功能集成→完整验证  
- [ ] **必须使用标准模板**：以下4个模板是强制格式，不可自创
- [ ] **文件位置固定**：必须存放在`docs/NOVEL_CREATION_TASKS/`目录

#### 违规行为零容忍：
- ❌ **生成多个Epic文件** → Epic0成功案例：只有1个文件
- ❌ **自创拆解结构** → 必须严格按4-Story模板  
- ❌ **偏离标准模板** → 以下模板是权威标准
- ❌ **文件命名不规范** → 格式：`【Epic[编号]】[Epic名称].md`

### 2.2 统一防改错约束机制

#### 修改前强制步骤（所有Story通用）
- [ ] **完整阅读相关代码**：使用Read工具阅读所有相关文件
- [ ] **理解现状确认**：用自己的话描述当前代码的工作原理
- [ ] **明确修改边界**：具体列出要修改的文件和函数
- [ ] **识别保护区域**：明确哪些代码绝对不能修改

#### 核心保护区域（绝对禁止修改）
- [ ] 已定义的API接口签名和响应格式结构：`{success, data, error, timestamp}`
- [ ] 核心数据结构定义和状态管理模型
- [ ] 错误处理基础框架和验证中间件
- [ ] API响应格式标准定义

#### 安全修改原则
- [ ] **向后兼容**：新功能不破坏现有功能和API接口
- [ ] **原子修改**：每次只修改一个具体功能点
- [ ] **即时验证**：修改后立即验证功能正常
- [ ] **数据结构兼容**：只能扩展字段，不能修改现有字段

### 2.3 Story标准模板体系

🔒 **强制模板警示** 🔒  
**以下4个模板是AI必须严格复制的权威格式，不得修改、扩展或自创其他格式！**

#### **🚨 Story 1: 界面功能开发模板 [强制使用]**
```markdown
# Story N.1: [功能]界面功能开发

## 开发目标
[具体要实现的界面功能和用户交互]

## 技术实现要求
### 界面开发规范
- **组件库**：Shadcn/ui，严格使用黑白灰配色方案
- **类型安全**：TypeScript强制类型检查，完整类型定义
- **状态管理**：Zustand管理状态，明确状态边界
- **响应式设计**：支持不同屏幕尺寸适配

### 界面开发清单
- [ ] [具体界面1]：[功能描述]
- [ ] [具体界面2]：[功能描述]
- [ ] [具体界面3]：[功能描述]

### 开发规范
- **前端目录**：严格按照 src/client/components/[模块]/[组件名]/ 组织
- **文件命名**：组件文件.tsx + 样式文件.module.css + 类型文件.types.ts
- **代码质量**：ESLint检查通过，无TypeScript错误

## 验收标准
- [ ] 界面功能完全符合PRD设计规范
- [ ] 所有用户交互正常工作
- [ ] 响应式布局在不同屏幕下正常显示
- [ ] TypeScript编译无错误
- [ ] 界面组件可复用性良好

## 开发步骤依赖
**前置条件**：[需要先完成的准备工作]
**后续步骤**：为Story 2服务逻辑开发提供界面基础
```

#### **🚨 Story 2: 服务逻辑开发模板 [强制使用]**
```markdown
# Story N.2: [功能]服务逻辑开发

## 开发目标
[具体要实现的业务逻辑和服务能力]

## 技术实现要求
### 服务开发规范
- **框架**：Express + TypeScript，严格MVC架构
- **错误处理**：分层错误类，统一错误响应格式
- **安全机制**：helmet + cors + 数据验证
- **性能优化**：异步处理优化

### 服务开发清单
- [ ] **路由层**：/api/[模块]/[接口] 路由定义
- [ ] **服务层**：核心业务逻辑实现
- [ ] **数据层**：文件操作和状态管理
- [ ] **中间件**：认证/校验/日志中间件

### 重点开发模块
根据Epic特点，重点实现：
- **AI服务模块**：Gemini API + PromptX MCP集成
- **文件操作模块**：本地文件读写和File System Access API
- **项目管理模块**：文件状态管理和项目导入
- **记忆管理模块**：PromptX记忆管理

## 验收标准
- [ ] 服务功能完全符合业务需求
- [ ] 错误处理和重试机制完整
- [ ] 性能满足响应时间要求（<1s）
- [ ] 核心业务逻辑测试通过
- [ ] API接口全流程验证通过

## 开发步骤依赖
**前置条件**：Story 1界面功能已完成
**技术依赖**：Gemini API密钥、PromptX MCP服务
**后续步骤**：为Story 3功能集成提供服务基础
```

#### **🚨 Story 3: 功能集成开发模板 [强制使用]**
```markdown
# Story N.3: [功能]功能集成开发

## 开发目标
完成界面与服务的集成，实现完整的功能流程

## 技术实现要求
### 集成开发规范
确保界面与服务的无缝连接：
```typescript
interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: number;
}
```

### 集成开发要点
- **接口调用**：前端正确调用后端API接口
- **数据传输**：请求参数和响应数据格式正确
- **错误处理**：前端正确处理后端返回的错误信息
- **状态管理**：前端状态与后端数据保持同步

### 集成开发清单
- [ ] 界面与API的连接调试
- [ ] 数据流验证和错误处理
- [ ] 用户交互完整流程测试
- [ ] HTTP API接口集成验证

## 验收标准
- [ ] 功能集成完整准确
- [ ] 界面与服务数据流通畅
- [ ] 错误处理机制完善
- [ ] 功能性能满足要求

## 开发步骤依赖
**前置条件**：Story 1界面功能和Story 2服务逻辑都已完成
**后续步骤**：为Story 4完整功能验证提供集成基础
```

#### **🚨 Story 4: 完整功能验证模板 [强制使用]**
```markdown
# Story N.4: [功能]完整功能验证

## 验证目标
验证完整功能从用户界面到业务服务的端到端流程

### 验证约束原则
- [ ] **只验证不修改**：验证过程中发现问题只记录，不直接修改代码
- [ ] **完整流程验证**：从用户操作到最终结果的完整链路
- [ ] **异常场景覆盖**：确保异常情况得到正确处理

## 验证场景清单
- [ ] **正常流程**：[用户操作] → [界面反应] → [后端处理] → [结果返回]
- [ ] **异常场景**：[错误输入] → [错误处理] → [用户提示]
- [ ] **边界情况**：[极端数据] → [系统处理] → [稳定性验证]

## 功能验证标准
- [ ] 用户界面操作流畅自然
- [ ] 数据处理准确无误
- [ ] 错误处理用户友好
- [ ] 性能满足PRD要求
- [ ] 符合业务流程规范

## 回归测试
- [ ] 相关功能模块回归测试
- [ ] 系统稳定性验证
- [ ] 用户体验评估

## 开发步骤依赖
**前置条件**：前3个Story全部完成
**输出结果**：Epic功能完全就绪，可进入下个Epic
```

### 2.4 开发规范标准

#### 界面开发规范
- **组件库**：Shadcn/ui，严格使用黑白灰配色方案
- **类型安全**：TypeScript强制类型检查，完整类型定义
- **状态管理**：Zustand管理状态，明确状态边界
- **响应式设计**：支持不同屏幕尺寸适配
- **前端目录**：严格按照 src/client/components/[模块]/[组件名]/ 组织
- **文件命名**：组件文件.tsx + 样式文件.module.css + 类型文件.types.ts
- **代码质量**：ESLint检查通过，无TypeScript错误

#### 服务开发规范
- **框架**：Express + TypeScript，严格MVC架构
- **错误处理**：分层错误类，统一错误响应格式
- **安全机制**：helmet + cors + 数据验证
- **性能优化**：异步处理优化
- **服务分层**：路由层→服务层→数据层→中间件层

#### 集成开发规范
确保界面与服务的无缝连接：
```typescript
interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: number;
}
```

---

## 三、质量保证(15%)

### 3.1 开发标准
- **代码规范**：TypeScript严格模式，ESLint检查
- **测试覆盖**：核心业务逻辑单元测试，API集成测试
- **性能要求**：接口响应<1s，界面交互<100ms
- **兼容性**：支持主流浏览器最新2个版本

### 3.2 统一验收标准
- **功能完整性**：严格按PRD功能要求验收
- **用户体验**：符合界面设计和交互规范
- **稳定可靠**：错误处理完善，系统健壮
- **性能达标**：满足响应时间和资源占用要求

### 3.3 完成后强制验证清单

#### 通用验证标准
- [ ] **功能验证**：新功能按预期工作
- [ ] **兼容性验证**：原有功能仍然正常
- [ ] **错误处理验证**：异常场景处理正确
- [ ] **性能验证**：响应时间符合要求

#### 专项验证场景
- [ ] **正常流程**：[用户操作] → [界面反应] → [后端处理] → [结果返回]
- [ ] **异常场景**：[错误输入] → [错误处理] → [用户提示]
- [ ] **边界情况**：[极端数据] → [系统处理] → [稳定性验证]

#### 回归测试
- [ ] 相关功能模块回归测试
- [ ] 系统稳定性验证
- [ ] 用户体验评估

### 3.4 特殊处理规则

#### AI服务集成特殊性
- **Gemini API优先**：当前版本只支持Gemini，但架构预留扩展性
- **PromptX MCP集成**：严格按MCP协议标准实现
- **4角色系统**：总监→完整4角色的渐进式集成策略

#### 文件操作特殊性
- **本地化优先**：优先File System Access API，降级到上传下载
- **实时同步**：30秒自动保存+手动保存双重机制
- **目录规范**：严格的4目录结构识别和创建

#### 界面交互特殊性
- **双栏架构**：320px左侧+自适应右侧的固定布局
- **双层Tab**：顶层文件Tab+内层依赖链Tab的复杂交互
- **极简设计**：黑白灰配色，Shadcn/ui组件库

---

## 四、工具支撑(10%)

### 4.1 AI连续工作机制

#### 核心问题：AI记忆断裂
**问题**：AI无法保持开发上下文连续性，导致重复开发、冲突修改、架构偏离
**解决方案**：文档驱动的外化记忆机制

#### Epic内状态管理（最简方案）
每个Epic文件增强结构：
```markdown
# Epic N: [Epic名称]

## 📋 开发状态（AI必读必写）
### 当前进度
- [ ] Story N.1: 前端UI组件开发 - 状态：[未开始/进行中XX%/已完成]
- [ ] Story N.2: 后端业务服务开发 - 状态：[未开始/进行中XX%/已完成]  
- [ ] Story N.3: 接口协议制定和集成 - 状态：[未开始/进行中XX%/已完成]
- [ ] Story N.4: 端到端功能验证 - 状态：[未开始/进行中XX%/已完成]

### 正在进行的工作
- **当前Story**：[具体Story编号和名称]
- **具体任务**：[当前正在做什么]
- **修改文件**：[涉及哪些文件]
- **预期完成**：[预计何时完成]

### 关键决策和约束
- **技术决策**：[本Epic确定的重要技术方案]
- **API设计**：[新增或修改的接口]
- **数据结构**：[重要的数据模型变更]
- **限制条件**：[遇到的技术限制或问题]

### 依赖关系和约束
#### 来自前置Epic的关键约束
- [具体约束1]：[详细说明]
- [具体约束2]：[详细说明]

#### 本Epic产出的关键决策（影响后续Epic）
- [待完成后填写]：[本Epic确定的设计决策和约束]

## Epic详细拆解
[原有的Story拆解内容]
```

### 4.2 AI执行规范

#### 执行前检查清单（每个Story都必须执行）
```markdown
## 🚨 开始任何Story前必须完成以下检查：

### Step 0: 状态恢复（记忆连续性保证）
- [ ] **强制读取当前Epic文件**：完整阅读当前Epic的"开发状态"部分
- [ ] **理解项目当前状态**：明确当前在哪个Story，做到什么程度
- [ ] **确认任务边界**：明确这次要做什么，不做什么
- [ ] **识别约束条件**：检查前置Epic的约束和本Epic的限制

### Step 1: 理解阶段
- [ ] 使用Read工具完整阅读所有相关代码文件
- [ ] 用自己的话描述当前代码的工作原理
- [ ] 明确说明要实现的功能目标

### Step 2: 边界确认
- [ ] 具体列出要修改的文件和函数
- [ ] 明确标识绝对不能修改的保护区域
- [ ] 确认修改方式符合向后兼容原则

### Step 3: 安全准备
- [ ] 制定原子化的修改步骤（每步只改一个功能点）
- [ ] 确认每步修改后的验证方式
- [ ] 准备问题出现时的快速回滚方案
```

#### 执行中约束
- **原子修改原则**：每次只修改一个具体功能点，修改后立即验证功能正常
- **兼容性原则**：API接口只能扩展不能破坏，数据结构只能增加字段不能删除或重命名
- **验证原则**：新功能必须按预期工作，原有功能必须仍然正常

#### 问题处理机制
遇到以下情况必须立即停止：理解不清楚、影响不确定、验证失败、兼容性问题

处理流程：立即停止→记录问题→分析原因→重新制定方案→从Step 1重新开始

#### 状态保存
完成任何开发工作后必须同时更新：
1. 强制更新当前Epic文件的"开发状态"部分
2. 创建时间戳开发总结文件：`docs/开发总结/[YYYY-MM-DD_HH-mm]_[具体内容].md`

### 4.3 文档管理规范

#### Epic文档存放规范
🚨 **文档命名强制规范** 🚨
- **格式**：`【Epic[编号]】[Epic名称].md`
- **位置**：`项目根目录/docs/NOVEL_CREATION_TASKS/`
- **数量**：每个Epic只能生成1个文件
- **约束**：所有Epic拆解文档统一存放在docs/NOVEL_CREATION_TASKS目录

⚠️ **Epic0正确示例**：`【Epic0】技术环境搭建.md` → 1个文件，标准格式，成功完成  
❌ **Epic1错误示例**：生成了2个文件，违反标准，需要纠正

### 4.4 核心原则总结
- **奥卡姆剃刀**：用最简单的方式解决记忆连续性问题
- **文档驱动**：AI的"大脑"外化到文件系统，信息持久化
- **强制执行**：状态管理嵌入工作流程，不可绕过
- **串行开发**：同时只关注一个Epic，避免复杂的并发状态管理

---

**核心目标**：通过文档驱动的状态管理确保AI记忆连续性，同时通过系统性约束避免破坏性修改。每个检查都是必须项，不是可选项。